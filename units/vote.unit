
Command: !vote !poll

Help: Usage: !vote, !vote <choice> [choice...]|See the current poll, or vote in a poll.  To vote, simply type '!vote #', with # being the number for the choice you choose.  Some polls allow voting for more than one option; simply type each number seperated by a space, e.g. "!vote 1 3".|+|Advanced Usage: !vote new <prompt> 1) <text> 2) <text>...|Create a new poll.  <prompt> will be displayed when a viewer types !vote, followed by each choice.  Talon_Bot looks for a number followed by a right parenthesis|Does it?  Does the bot care what the options are?|Advanced Usage: !vote end|End voting on the current poll.|Advanced Usage: !vote results|Display the results of the last completed poll.



Code:
# Handle creating a poll
if ( &admin_test($tags) and $args =~ /^new (.*)/i )  {
	# Set the poll prompt
	$VARS{poll} = $1;
	# Blank the votes
	$VARS{votes} = {};
	return;
	}

# Handle ending a poll
if ( &admin_test($tags) and $args =~ /^(end|stop)$/i )  {
	# Reset results
	$VARS{results} = {};
	
	# Stash the prompt
	$VARS{result} = $VARS{poll};
	
	# Tally votes
	foreach ( values %{$VARS{votes}} )  {
		my @raw = split /\s+/;
		# Check for duplicates
		my @votes;
		foreach (@raw)  {
			# Cap the value so the array doesn't get stupidly large
			next if ( $_ > 100 );
			$votes[$_]++;
			}
		for (my $i = 1; $i <= @votes; $i++)  {
			$VARS{results}{$i}++ if $votes[$i];
			}
		
		}
	
	$VARS{poll} = '';
	&chat('Voting closed.');
	return;
	}

# Handle saving a poll
if ( &admin_test($tags) and $args =~ /^save( .*)?$/i )  {
	# Check for a current poll
	unless ($VARS{poll})  {
		&chat("No current poll.");
		return;
		}
	
	# Check for a prior saved poll
	if ($DATA{poll})  {
		if ( $1 eq ' -f' )  {
			$DATA{poll} = '';
			$DATA{votes} = '';
			}
		else  {
			&chat("A previous poll is saved.  Use '!vote save -f' to overwrite.");
			return;
			}
		}
	
	# Store the prompt
	$DATA{poll} = $VARS{poll};
	
	# Marshall votes into a string
	my $votes;
	foreach (keys %{$VARS{votes}})  {
		debug 1,$_;
		my $uservote = $VARS{votes}{$_};
		# Remove whitespace from votes string
		$uservote =~ s/\s+/,/g;
		$votes .= "$_:$uservote ";
		
		}
	
	# Shave off the last space.
	$votes =~ s/ $//;
	
	# Store the result
	$DATA{votes} = $votes;
	
	# Remove the current poll
	$VARS{poll} = '';
	&chat("Poll saved.  To restore it, type '!vote load'");
	
	
	return;
	}

# Handle loading a poll
if ( &admin_test($tags) and $args =~ /^load$/i )  {
	# Check for a saved poll
	unless ($DATA{poll})  {
		&chat("No saved poll.");
		return;
		}
	
	# Check for a currently running poll
	if ($VARS{poll})  {
		&chat("A poll is currently running.  End it before loading a saved poll.");
			return;
			}
	
	# Load the prompt
	$VARS{poll} = $DATA{poll};
	
	# Unmarshall votes from storage
	my $votes;
	foreach (split / /, $DATA{votes})  {
		debug 1,$_;
		my ($user, $vote) = split /:/;
		
		# Put back the spaces
		$vote =~ s/,/ /g;
		
		$VARS{votes}{$user} = $vote;
		}
	
	# Remove the saved poll
	$DATA{poll} = '';
	$DATA{votes} = '';
	
	&chat("Poll restored.");
	
	
	return;
	}

# Handle displaying results
if ( &admin_test($tags) and $args =~ /^result(s)?$/i )  {
	&chat($VARS{result});
	my @ranking = sort { $VARS{results}{$b} <=> $VARS{results}{$a} } keys %{$VARS{results}};
	&chat("Choice $_: $VARS{results}{$_}") foreach @ranking;
	return;
	}

# That's all the admin commands
# If there is no current poll, stop here
unless ($VARS{poll})  {
	&chat("No current poll.");
	return;
	}

# Print the poll by default
unless ($args)  {
	my $message = "Current poll: $VARS{poll}";
	# Display current vote if user has voted.
	$message .= " Current vote for $user: $VARS{votes}{$tags->{'user-id'}}" if ($VARS{votes}{$tags->{"user-id"}});
	$message .= "  Total votes: " . int( keys %{$VARS{votes}} );
	&chat($message);
	return;
	}

# Only numbers and spaces allowed
unless ( $args =~ /^[\d\s]*$/ )  {
	&chat("Votes must only consist of numbers, separated by spaces.");
	return;
	}

# Store votes by user-id, to allow easy changing.
$VARS{votes}{$tags->{"user-id"}} = $args;
&chat("Vote received.");
