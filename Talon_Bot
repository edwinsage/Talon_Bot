#!/usr/bin/perl

# Talon_Bot, a multipurpose bot for Twitch chat
my $version = '0.3.0-alpha';
# Copyright 2020, 2021 Michael Pirkola

# This program is free software: you can redistribute it and/or modify
# it under the terms of version 3 of the GNU Affero General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# This number should be changed to the current major.minor version number any
# time any change is made to the database format that is not fully forwards and
# backwards compatible with the previous parsing code.
my $dbVersion = '0.3';



use v5.20;

use lib './';
use IO::Socket::SSL;
use Text::Wrap qw(wrap $columns);
use Getopt::Long;
use HTTP::Tiny;
use Twitch;

# Predeclare debug prototype.
sub debug ($$);

# This is how to run this program!
sub usage  {
	print <<"END_HELP";
Usage:
 $0 [options]

$0 is a multipurpose bot for Twitch chat.

Options:
    -h   --help         Print this help text
    -c   --config       Specify a config file other than .Talon_Bot.rc
    -t   --test         Don't connect to Twitch chat, just run interactively
    -d   --debug        Enable extra debug output

END_HELP
#'# <- Fix syntax highlighting.
	exit;
	}





##############
##  Config  ##
##############

# Make a list of places to check, until one is found.
# Talon_Bot will use the first available file from this list,
# unless a filename is given with --config.
my @configs = (
    '.Talon_Bot.rc',
    'Talon_Bot.rc',
    $ENV{'HOME'} . '/.Talon_Bot.rc',
    $ENV{'HOME'} . '/Talon_Bot.rc'
    );



# Set config defaults.
my %cfg = (
	source_code_url => 'https://github.com/edwinsage/Talon_Bot',
	host  => 'irc.chat.twitch.tv',
	port  => '6697',
	user  => 'Invalid!',
	auth  => 'Invalid!',
	width => '25',
	bot_color => '8A2BE2',
	user_color => 'BBBBBB',
	tempfile_units => 'units.tmp',
	unit_matrix_message => 'Not configured.  Please edit your Talon Bot config file.',
	
	data_file => 'data.db'
	);



# Parse command line options.
Getopt::Long::Configure("bundling");
my ( $config_file, $test , $debug );

GetOptions( "test|t" => \$test,
	    "config|c=s" => \$config_file,
	    "debug|d+" => \$debug,
	    "help|h" => \&usage
	    );



# Let's locate our config file.
# First priority is given to a command line argument.
# If that's not specified, we have to start looking.
my $found;
if ($config_file)  {
	# Note whether the file actually exists yet.
	$found = -e $config_file;
	}
else  {
	# Not specified, so we go looking.
	foreach (@configs)  {
		if ( -e $_ )  {
			$config_file = $_;
			$found = 1;
			last;
			}
		}
	}

if ($found)  {
	say "Using config file $config_file.";
	}
else  {
	# Create a new config file if none were found.
	# The block below contains the template for a new
	# config file, which will be filled with the default
	# config options specified above.
	
	# When writing a new file, default to a specified filename,
	# or the first choice in the list of filenames to check.
	$config_file = $configs[0] unless $config_file;
	say "Creating new config file $config_file.";
	open( CONFIG, '>', $config_file )
	    or die "Could not find or create config file.";
	print CONFIG <<"END_CONFIG";
# Settings for Talon_Bot
# Defaults are shown.  To run, user and auth must be set.
# Other options may be uncommented and changed.


#########################
##  Essential Config!  ##
#########################

# Talon_Bot requires a Twitch user to log in as.
user = $cfg{user}

# Twitch OAuth token.
auth = $cfg{auth}



#############
##  Files  ##
#############

# Log file to save all chat messages to.
#chatlog = $cfg{chatlog}

# Log file for raw IRC traffic.  Useful for debugging.
#rawlog = $cfg{rawlog}

# Persistent storage for units data.
#data_file = $cfg{data_file}

# Temporary file for units code.
#tempfile_units = $cfg{tempfile_units}



#####################
##  Other Options  ##
#####################

# Specify the Twitch chat channel to connect to.
# Default is to match the username.
#channel = $cfg{channel}

# Width of terminal output.
#width = $cfg{width}

# Default color for bot messages on terminal output.
#bot_color = $cfg{bot_color}

# Default color for user messages on terminal output.
# Overridden if the user has set a color.
#user_color = $cfg{user_color}

# Host and port of the Twitch IRC server.
# These should not need changing.
#host = $cfg{host}
#port = $cfg{port}

# Location of the source code for the bot.  If you make changes to the software,
# you must host the code somewhere and change this link to point to it.
#source_code_url = $cfg{source_code_url}



###################
##  Unit Config  ##
###################

# If this option is uncommented, then only the listed unit files will load.
# The default is to load all available unit files.
#unit_whitelist = rule, shout, vote

# Any unit files listed here will never be loaded.
#unit_blacklist = 



# The message to display for the !matrix command.
#unit_matrix_message = $cfg{unit_matrix_message}

END_CONFIG
	close CONFIG;
	chmod 0600, $config_file
	    or warn "Could not set permissions on $config_file.";
	say "You will need to edit at least the user and " . 
	    "auth lines to be able to connect to Twitch.";
	}



# Read config from file.
open ( FILE, $config_file ) or die "Could not find $config_file";
while (<FILE>)  {
	# Skip comments and blank lines
	next if ( /^\s*#/ or /^\s*$/ );
	chomp;
	# Remove leading and trailing spaces
	s/^\s*(.*?)\s*/$1/;
	die "Config file error: line $_ unparseable in $config_file.\n" unless /=/;
	my ( $key, $value ) = split /\s*=\s*/;
	$cfg{$key} = $value;
	}
close FILE;



# Check essential options
unless ($test)  {
	die "'user' not set in $config_file!" if ( $cfg{user} eq 'Invalid!' );
	die "'auth' not set in $config_file!" if ( $cfg{auth} eq 'Invalid!' );
	}



# Handle channel name
$cfg{channel} = $cfg{user} unless $cfg{channel};
$cfg{channel} = '#' . $cfg{channel} unless ( $cfg{channel} =~ /^#/ );



# Open log files, if configured.
if ( $cfg{rawlog} )  {
	open ( RAWLOG, ">>", $cfg{rawlog} )
	  or die "Could not open $cfg{rawlog} for appending.";
	RAWLOG->autoflush(1);
	}
if ( $cfg{chatlog} )  {
	open ( LOG, ">>", $cfg{chatlog} )
	  or die "Could not open $cfg{chatlog} for appending.";
	LOG->autoflush(1);
	}



# Create the command list, starting with builtins.
my %command = (
	units => \&units,
	license => \&license,
	help => \&help
	);

# Used for listing commands
my @command_list = keys %command;


# Initialize help.
my %help;




#############
##  Units  ##
#############

# Load units.
my @unit_files = <units/*.unit>;
my @output;

debug 1,"Unit files: " . join (', ', @unit_files);


# Build the list of units to load.
my %units;

foreach my $file (@unit_files)  {
	my ($namespace) = $file =~ /(\w+)\.unit$/;
	unless ( $namespace )  {
		warn "Invalid unit name $file.  Units must be named using only"
		    ."alphanumeric characters and underscore.  Skipping...";
		next;
		}
	$units{$namespace} = 1;
	
	}

if (defined $cfg{unit_whitelist})  {
	my @white = split /,\s*/, $cfg{unit_whitelist};
	my %whitelist;
	# This line actually makes a hash.
	@whitelist{@white} = (1) x @white;
	foreach (keys %units)  {
		next if $whitelist{$_};
		debug 1,"Unit $_ is not on whitelist, skipping...";
		delete $units{$_};
		}
	}

my @blacklist = split /,\s*/, $cfg{unit_blacklist};
foreach (@blacklist)  {
	next unless $units{$_};
	debug 1,"Unit $_ is blacklisted, skipping...";
	delete $units{$_};
	}



# Parse each one.
foreach my $unit (keys %units)  {
	my $file = 'units/' . $unit . '.unit';
	unless (open ( UNIT, "<", "$file" ))  {
		warn "Could not open unit file $file for reading.";
		delete $units{$unit};
		next;
		}
	
	# Shlorp in the file by sections.
	my @shlorp;
	BLOCK: while ( <UNIT> )  {
		debug 2,"Line read from unit file";
		# Skip checks if we're at the end.
		debug 3, "Check1";
		# Ignore blank lines.
		next if ( /^\s*$/ and !eof );
		chomp;
		push ( @shlorp, $_ );
		
		debug 3,"Check2";
		# Get one block at a time.
		next unless ( /^\&\&/ or eof );
		
		debug 3,"Check3";
		# Get rid of the ampersands.
		pop @shlorp if /^\&\&/;
		
		debug 2,"Shlorped";
		# Make sure we got something.
		next unless @shlorp;
		
		debug 2,"@shlorp";
		# Right now there are only command sections.
		# More parsing will come later.
		
		# Parse commands
		my %header;
		while (@shlorp)  {
			# Peel off lines until we hit the code block.
			$_ = shift @shlorp;
			next if /^\s*$/;
			
			
			if ( /^Code:/ )  {
				debug 2,"Code block start";
				last;
				}
			elsif ( /(.*?): (.*)/ ) {
				$header{$1} = $2;
				debug 3,"Header $1 = $2";
				}
			else  {
				#!# This needs a far better diagnostic message.
				warn "Could not parse line:\n\t$_\n";
				last;
				}
			
			
			}
		
		# There should at least be the commands in %header
		# Check and make sure something isn't obviously wrong.
		unless ( $header{Command} )  {
			warn "Command line not found.";
			@shlorp = ();
			next;
			}
		
		# Process the Command line
		my @keys = split ( /\s+/, $header{Command} );
		
		my $main = $keys[0];
		$main =~ s/!//;
		
		
		
		
		
		
		
		# Add the command to the command hash.
		debug 1,"Adding command $main";
		foreach ( @keys )  {
			if ( !(/^!\w+$/) )  {
				warn "Error parsing unit file: $_ is not a proper command.";
				next BLOCK;
				}
			s/!//;
			if (defined $command{$_})  {
				warn "Command name $_ already exists.";
				next BLOCK if ( $_ eq $main );
				next;
				}
			
			# Checks out
			$command{$_} = \&{"cmd_$main"};
			
			
			
			
			}
		# Add the main name to the command list.
		push @command_list, $main;
		
		
		# Load help text.
		if ($header{Help})  {
			debug 1,"Help found in $main";
			my @text = split ( /\|/, $header{Help} );
			foreach (@keys)  {
				$help{"$_"} = \@text;
				debug 3,"help item $_";
				}
			debug 2,int(@text);
			}
		
		
		
		# Create the subroutine.
		debug 1, 'Pushing subroutine to @output';
		push @output, "sub cmd_$main  {\n\t"
		    . 'my ( $user, $tags, $args, $cfg ) = @_;'
		    . "\n";
		
		foreach (@shlorp)  {
			# Translate to proper code
			s/([\$\%]\{?)VARS/$1vars{$unit}/g;
			s/([\$\%]\{?)DATA/$1data{$unit}/g;
			
			
			push ( @output, "\t$_\n" );
			}
		push ( @output, "\t}\n\n" );
		@shlorp = ();
		}
	close UNIT;
	}




# Write the result to a temporary file.
open ( UNITS, ">", $cfg{tempfile_units} );
print UNITS <<'END_OF_DATA_SUBS';
use v5.20;

my ( %vars, %data, $lastdump );


sub load_data  {
	my ($file, $version) = @_;
	my ($major_ver, $minor_ver) = $version =~ /^(\d+)\.(\d+)/;
	
	# First check if the data file exists.
	return unless ( -e $file );
	
	
	# try to load the database.
	open (IN, '<', $file)
	    or die "Could not open data file $file for reading.";
	
	# Get database version requirement from the first line only.
	my $version_line = <IN>;
	chomp $version_line;
	
	my ($req_version) = $version_line =~ /^v(\d+\.\d+)/;
	
	die "Could not read version string from data file $file"
	    unless $version_line =~ /^v(\d+)\.(\d+)/;
	
	die "Database file $file needs Talon_Bot version $req_version.0 or "
	    ."better to read it.  Current version is only $version."
	    if ($major_ver < $1 or $minor_ver < $2);
	
	while (my $line = <IN>)  {
		chomp;
		
		# We don't care about backups here.
		if ($line =~ /^\&\&/)  {
			close(IN);
			return;
			}
		
		
		# Old code first.
		if ($req_version < 0.1)  {
			# Put old database loading method here.
			# 0.1 and 0.2 databases can be read by 0.3 rules.
			}
		else  {  # Current version: 0.3
			# All lines should match this pattern.
			# There should be no funny business here.
			$line =~ /([\w_]+):([\w_]+): (.*)/
			    or die "Error reading database file $file.  Line not parseable:\n$line";
			
			# Store the data.
			$data{$1}{$2} = $3;
			}
		}
	close(IN);
	}


sub dump_data  {
	my ($file, $dbVersion) = @_;
	
	my @old;
	my $read_fail;
	# Load in up to the last 4 entries as backup
	if (-e $file)  {
		unless ( open (IN, '<', $file) )  {
			warn "Unable to open $file for updating.\n";
			$read_fail = 1;
			}
		
		my $entry;
		while (<IN>)  {
			unless (/^\&\&/)  {
				# Add the line to the current entry.
				$entry .= $_;
				next unless eof;
				}
			# Otherwise, push the whole entry to the list.
			push @old, $entry;
			$entry = '';
			# Stop at 4.
			last if (@old >= 4);
			}
		
		close IN;
		}
	
	
	unless ( open (OUT, '>', "${file}.tmp") )  {
		warn "Unable to write to ${file}.tmp\n";
		return;
		}
	# We don't need the current version,
	# we need the last time the database format was changed.
	my $time = &timestamp;
	print OUT "v$dbVersion - written $time\n";
	
	debug 2,"starting hash dump $data{boop}{boop}";
	# %data is a hash of hashes.  Double-loop through it.
	foreach my $unit (keys %data)  {
		debug 2,"Looping for unit $unit";
		foreach my $var ( keys %{$data{$unit}} )  {
			debug 2,"Loop for variable $var in $unit";
			# These keys need checking.  Alphanumeric and _ only.
			unless ($var =~ /^\w+$/a)  {
				warn "Could not store value $unit:$var - only alphanumeric characters and underscore are allowed for names.";
				next;
				}
			# Since we're storing these in a line-based format,
			# newlines are not allowed.
			if ( $data{$unit}{$var} =~ /\n/ )  {
				warn "Stripping newlines from $data{$unit}{$var}.  Stored data cannot contain newlines.";
				$data{$unit}{$var} =~ s/\n//g;
				}
			# Write the data.
			print OUT "$unit:$var: $data{$unit}{$var}\n";
			
			}
		}
	
	# Append old data as backup.
	print OUT "&&\n$_" foreach ( @old );
	
	
	unless ( close(OUT) )  {
		warn "Warning: couldn't complete save to ${file}.tmp!";
		return;
		}
	
	# Don't replace the old file if there was a read error.
	if ($read_fail)  {
		# Try renaming?
		if ( rename $file, "${file}.old" )  {
			debug 1, "Renamed old database, as it could not be read for prepending.";
			}
		else  {
			# This is all bad news and a sign something went very wrong.
			# so we'll not be too thorough in handling it.
			warn "Database file not replaced.  Leaving as ${file}.tmp ...";
			return;
			}
		}
	
	
	if ( rename "${file}.tmp", $file )  {
		debug 1, "Dumped data to file.";
		$lastdump = time;
		}
	else  {
		warn "Could not replace old data file ${file}";
		}
	
	}

END_OF_DATA_SUBS






print UNITS foreach @output;
# If everything works, this should be the return value.
print UNITS "\n1;\n";
close UNITS;


### Run the units file

my $return = do $cfg{tempfile_units};
if ($return)  {
	debug 1,"Loaded $cfg{tempfile_units} successfully.";
	}
else  {
	die "Couldn't parse $cfg{tempfile_units}: $@" if $@;
	die "Couldn't do $cfg{tempfile_units}: $!" unless defined $return;
	die "Couldn't run $cfg{tempfile_units}";
	}










# Set up other variables.
$columns = $cfg{width};







@command_list = sort @command_list;

# Load data file
&load_data( $cfg{data_file}, $version );





##################
##  Connection  ##
##################

my $sock;
unless ($test)  {
	# Using SSL, because PLAINTEXT BAD
	$sock = IO::Socket::SSL->new("$cfg{host}:$cfg{port}")
	    or die "Can't open socket: $@";
	
	
	say 'Logging in.';
	say $sock "PASS oauth:$cfg{auth}";
	say $sock "NICK $cfg{user}";
	say $sock "JOIN $cfg{channel}";
	
	say 'Looking for ACK.';
	my $first = <$sock>;
	say "$first YEAH!";
	die unless ( $first =~ /Welcome/ );
	
	say 'ACK received.';
	say $sock 'CAP REQ :twitch.tv/membership twitch.tv/tags twitch.tv/commands';
	}
else  {
	say 'Running in test mode, not connecting to Twitch...';
	# Only load modules if needed.
	eval "use WrapHandles;use Symbol";
	$sock = Symbol::gensym;
	# The following lets us use STDIN and STDOUT like a socket.
	tie *$sock, 'WrapHandles', \*STDIN, \*STDOUT;
	}

# Signal handling, for clean exiting.
$SIG{INT}  = \&signal_handler;
$SIG{TERM}  = \&signal_handler;


# Move login output offscreen
print "\n" x 25;


# Make time global.
my $time;






#################
##  Main Loop  ##
#################

while ( <$sock> )  {
	if ( /^PING :tmi.twitch.tv/ )  {
		say $sock 'PONG :tmi.twitch.tv';
		next;
		}
	$time = &timestamp;
	
	
	print RAWLOG "$time $_" if $cfg{rawlog};
	
	# Parse received messages.   (@tag1=;tag2=meep ):(user)!user@user.tmi.twitch.tv  (PRIVMSG) #chan        ' :' (msg)
	my ( $tags, $user, $cmd, $msg ) = /^(@.*? )?:(?:(\w+)!)?(?:\w+@\w+.)?tmi.twitch.tv (\w+) $cfg{channel}(?: :)?(.*)?\r\n/;
	
	# Easy CLI testing version:
	if ($test)  {
		$tags = '@badges=broadcaster;color=#FF0000;display-name=TESTING;fake=yup;user-id=1234567890';
		$cmd = "PRIVMSG";
		$user = "$cfg{user}";
		$msg = $_;
		}
	
	# Parse tags.
	$tags =~ s/^@//;
	my @tags = split /;/, $tags;
	my %tag;
	foreach ( @tags )  {
		# Remove trailing spaces
		s/\s+$//;
		# Remove leading spaces
		s/^\s+//;
		unless ( /=/ )  {
			warn "Tag parsing error: $_ unparseable.";
			next;
			}
		my ( $key, $value ) = split /\s*=\s*/;
		$tag{$key} = $value;
		}
	
	if ( $cmd eq 'PRIVMSG' )  {
		# Print message.
		&term_out( $user, \%tag, $msg );
		
		# Log chat messages.
		print LOG "$time $user: $msg\n" if $cfg{chatlog};
		#say "Message: $msg";
		# Look for a command.
		if ( $msg =~ /^!(\w+)\s*(\S.*)?/ )  {
			my ( $c, $args ) = ($1, $2);
			#say $c, $args;
			$c =~ tr/A-Z/a-z/;
			# Execute command if it is in the list.
			&{$command{$c}}( $user, \%tag, $args, \%cfg ) if ( exists($command{$c}) );
			}
		
		
		
		}
	
	
	
	}



&logoff;





################
##  Commands  ##
################

sub units  {
	# Show loaded units
	# Enable and disable units
	# Reload unit files
	
	&chat("!units command not yet implemeted, sorry.");
	
	
	}



sub license  {
	&chat("Talon_Bot is distributed under the terms of the GNU Affero General Public License.  " .
	      "This means that you, the user, have the right to download, modify, and run the " .
	      "software yourself if you wish, under the same terms.  " .
	      "Source code is available at $cfg{source_code_url}");
	
	
	}



sub help  {
	my ( $user, $tags, $args ) = @_;
	# Get rid of ! if needed.
	$args =~ s/^\!//;
	
	
	if ($args eq 'units')  {
		&units;
		}
	elsif ($args eq 'license')  {
		&license;
		}
	# Default help
	elsif ( !($help{$args}) )  {
		#!# Find a better way to list commands.
		&chat("Available commands: !" . join (', !', @command_list)
		    . ".  For more information on a specific command, type '!help [command]'.");
		}
	else  {
		foreach ( @{$help{$args}} )  {
			if (/^\+/)  {
				# Either skip the +, or end.
				next if &admin_test($tags);
				return;
				}
			&chat($_);
			}
		}
	return;
	}




#######################
##  Other Functions  ##
#######################


sub term_out  {
	my ( $user, $tag, $msg ) = @_;
	my $status;
	# Check for mod status
	$status = '*' if &admin_test($tag);
	
	# Get user color.
	my ( $cr, $cg, $cb ) = %$tag{color} =~ /#(..)(..)(..)/;
	$cr = substr( $cfg{user_color}, 0, 2 ) unless defined $cr;
	$cg = substr( $cfg{user_color}, 2, 2 ) unless defined $cg;
	$cb = substr( $cfg{user_color}, 4, 2 ) unless defined $cb;
	
	# Decimal conversion
	$cr = hex $cr;
	$cg = hex $cg;
	$cb = hex $cb;
	
	# Wrap message text
	$msg = wrap(' ', ' ', $msg);
	
	# Print message.
	#print '\033[38;2;' . "$cr;$cg;${cb}m$user" . '\033[0m: ' . "$msg\n";
	print "$status\e[38;2;$cr;$cg;${cb}m$user\e[0m:\n$msg\n";
	}


sub chat  {
	my ( $msg ) = @_;
	say $sock "PRIVMSG $cfg{channel} :$msg";
	&term_out( $cfg{user},
	    { color => "#$cfg{bot_color}", badges => 'moderator' }, $msg );
	print LOG "$time $cfg{user}: $msg\n" if $cfg{chatlog};
	}


sub whisper  {
	my ( $user, $msg ) = @_;
	say $sock "PRIVMSG $cfg{channel} :/w $user $msg";
	print LOG "$time $cfg{user}: /w $user $msg\n" if $cfg{chatlog};
	}


sub admin_test  {
	my ($tag) = @_;
	return 1 if ( $tag->{badges} =~ /(broadcaster|moderator)/ );
	return 0;
	}


sub timestamp  {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
	return sprintf ( "%d\.%02d.%02d-%02d:%02d:%02d", ($year + 1900, $mon + 1, $mday, $hour, $min, $sec) );
	}


sub signal_handler  {
	say 'Logging off.';
	say $sock 'QUIT';
	&logoff;
	wait;
	exit;
	}


sub debug ($$)  {
	print "DEBUG$_[0]: $_[1]\n" if ($debug >= $_[0]);
	}


sub logoff  {
	&dump_data( $cfg{data_file}, $dbVersion );
	if ( $cfg{rawlog} )  {
		print RAWLOG "\n--\n\n";
		close RAWLOG
		  or warn "Could not close $cfg{rawlog}.";
		}
	if ( $cfg{chatlog} )  {
		print LOG"\n--\n\n";
		close LOG
		  or warn "Could not close $cfg{chatlog}.";
		}
	$sock->close();
	}
